#!/usr/bin/env python3
"""
Simple HTTP Audio Server for Sonos TTS
Serves audio files generated by Piper TTS to Sonos speakers
"""

import os
import sys
import logging
import threading
import time
from http.server import HTTPServer, SimpleHTTPRequestHandler
import socketserver
from urllib.parse import unquote
import mimetypes

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class AudioHTTPRequestHandler(SimpleHTTPRequestHandler):
    """Custom HTTP request handler for audio files"""

    def do_GET(self):
        """Handle GET requests for audio files"""
        try:
            # Decode URL path
            path = unquote(self.path)

            # Remove leading slash
            if path.startswith('/'):
                path = path[1:]

            # Construct full file path
            file_path = os.path.join(self.server.audio_dir, path)

            logger.info(f"Request for audio file: {file_path}")

            # Security check - only serve files from audio directory
            if not os.path.abspath(file_path).startswith(os.path.abspath(self.server.audio_dir)):
                logger.warning(f"Security violation: {file_path}")
                self.send_error(403, "Forbidden")
                return

            # Check if file exists
            if not os.path.exists(file_path):
                logger.warning(f"File not found: {file_path}")
                self.send_error(404, "File not found")
                return

            # Get file size
            file_size = os.path.getsize(file_path)

            # Determine MIME type
            content_type, _ = mimetypes.guess_type(file_path)
            if not content_type:
                # Default to audio/mpeg for Sonos compatibility
                if file_path.endswith('.mp3'):
                    content_type = 'audio/mpeg'
                elif file_path.endswith('.wav'):
                    content_type = 'audio/wav'
                else:
                    content_type = 'application/octet-stream'

            logger.info(f"Serving {file_path} as {content_type} ({file_size} bytes)")

            # Send response headers
            self.send_response(200)
            self.send_header('Content-Type', content_type)
            self.send_header('Content-Length', str(file_size))
            self.send_header('Accept-Ranges', 'bytes')
            self.send_header('Cache-Control', 'no-cache')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS')
            self.send_header('Access-Control-Allow-Headers', '*')
            self.end_headers()

            # Send file content
            with open(file_path, 'rb') as f:
                self.wfile.write(f.read())

        except Exception as e:
            logger.error(f"Error serving file: {e}")
            self.send_error(500, f"Internal server error: {e}")

    def log_message(self, format, *args):
        """Override to use our logger"""
        logger.info("%s - %s" % (self.address_string(), format % args))

class AudioServer:
    """Simple HTTP server for serving audio files"""

    def __init__(self, host='0.0.0.0', port=8080, audio_dir='/tmp/audio'):
        self.host = host
        self.port = port
        self.audio_dir = audio_dir
        self.server = None
        self.thread = None

        # Ensure audio directory exists
        os.makedirs(audio_dir, exist_ok=True)
        logger.info(f"Audio directory: {audio_dir}")

    def start(self):
        """Start the HTTP server in a background thread"""
        try:
            # Create server
            handler = AudioHTTPRequestHandler
            self.server = HTTPServer((self.host, self.port), handler)
            self.server.audio_dir = self.audio_dir

            # Start server in background thread
            self.thread = threading.Thread(target=self.server.serve_forever, daemon=True)
            self.thread.start()

            logger.info(f"Audio server started on http://{self.host}:{self.port}")
            logger.info(f"Serving files from: {self.audio_dir}")

            return True

        except Exception as e:
            logger.error(f"Failed to start audio server: {e}")
            return False

    def stop(self):
        """Stop the HTTP server"""
        if self.server:
            logger.info("Stopping audio server...")
            self.server.shutdown()
            self.server.server_close()
            self.server = None

        if self.thread:
            self.thread.join(timeout=5)
            self.thread = None

    def is_running(self):
        """Check if server is running"""
        return self.server is not None and self.thread is not None and self.thread.is_alive()

    def cleanup_old_files(self, max_age_seconds=300):
        """Clean up old audio files"""
        try:
            current_time = time.time()
            cleaned_count = 0

            for filename in os.listdir(self.audio_dir):
                file_path = os.path.join(self.audio_dir, filename)
                if os.path.isfile(file_path):
                    file_age = current_time - os.path.getmtime(file_path)
                    if file_age > max_age_seconds:
                        os.remove(file_path)
                        cleaned_count += 1
                        logger.debug(f"Cleaned up old file: {filename}")

            if cleaned_count > 0:
                logger.info(f"Cleaned up {cleaned_count} old audio files")

        except Exception as e:
            logger.warning(f"Error cleaning up old files: {e}")

def main():
    """Main function when run as script"""
    import argparse

    parser = argparse.ArgumentParser(description='Simple HTTP Audio Server for Sonos TTS')
    parser.add_argument('--host', default='0.0.0.0', help='Host to bind to (default: 0.0.0.0)')
    parser.add_argument('--port', type=int, default=8080, help='Port to bind to (default: 8080)')
    parser.add_argument('--audio-dir', default='/tmp/audio', help='Directory to serve audio files from')
    parser.add_argument('--cleanup-interval', type=int, default=60, help='Cleanup interval in seconds')

    args = parser.parse_args()

    # Create and start server
    server = AudioServer(host=args.host, port=args.port, audio_dir=args.audio_dir)

    if not server.start():
        sys.exit(1)

    logger.info("Audio server is running. Press Ctrl+C to stop.")

    try:
        # Main loop with periodic cleanup
        while True:
            time.sleep(args.cleanup_interval)
            server.cleanup_old_files()

    except KeyboardInterrupt:
        logger.info("Shutting down...")
    finally:
        server.stop()

if __name__ == '__main__':
    main()
