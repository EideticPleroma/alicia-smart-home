"""
Pytest configuration for MQTT Bus test suite
============================================

Configuration and fixtures for the Alicia Smart Home AI Assistant MQTT Bus test suite.
Provides common test setup, teardown, and shared fixtures.

Generated by MCP QA Orchestrator
Author: Cline MCP Implementation
Version: 1.0.0
"""

import pytest
import asyncio
import time
import logging
from typing import Dict, Any, Generator
from unittest.mock import Mock, patch

# Configure logging for tests
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


@pytest.fixture(scope="session")
def event_loop():
    """Create an instance of the default event loop for the test session."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


@pytest.fixture(scope="session")
def mqtt_broker_config():
    """MQTT broker configuration for tests."""
    return {
        "host": "localhost",
        "port": 1883,
        "secure_port": 8883,
        "websocket_port": 9001,
        "username": "test_user",
        "password": "test_password",
        "client_id_prefix": "test_"
    }


@pytest.fixture(scope="session")
def test_services_config():
    """Configuration for test services."""
    return {
        "services": [
            {
                "name": "test_stt_service",
                "port": 8001,
                "topics": ["alicia/voice/stt/#"],
                "capabilities": ["speech_to_text"]
            },
            {
                "name": "test_ai_service", 
                "port": 8002,
                "topics": ["alicia/voice/ai/#"],
                "capabilities": ["natural_language_processing"]
            },
            {
                "name": "test_tts_service",
                "port": 8003,
                "topics": ["alicia/voice/tts/#"],
                "capabilities": ["text_to_speech"]
            },
            {
                "name": "test_device_manager",
                "port": 8006,
                "topics": ["alicia/devices/#"],
                "capabilities": ["device_management"]
            }
        ]
    }


@pytest.fixture(scope="function")
def mock_mqtt_broker():
    """Mock MQTT broker for unit tests."""
    broker = Mock()
    broker.host = "localhost"
    broker.port = 1883
    broker.connected = True
    broker.messages = []
    
    def publish(topic, payload, qos=1, retain=False):
        message = {
            "topic": topic,
            "payload": payload,
            "qos": qos,
            "retain": retain,
            "timestamp": time.time()
        }
        broker.messages.append(message)
        return Mock(rc=0)  # Success
    
    def subscribe(topic, qos=1):
        return (0, 1)  # Success
    
    broker.publish = publish
    broker.subscribe = subscribe
    
    return broker


@pytest.fixture(scope="function")
def mock_security_gateway():
    """Mock security gateway for tests."""
    gateway = Mock()
    gateway.authenticate_service.return_value = True
    gateway.validate_topic_access.return_value = True
    gateway.encrypt_message.return_value = "encrypted_message"
    gateway.decrypt_message.return_value = "decrypted_message"
    return gateway


@pytest.fixture(scope="function")
def mock_device_registry():
    """Mock device registry for tests."""
    registry = Mock()
    registry.services = {}
    registry.devices = {}
    
    def register_service(service_data):
        service_name = service_data["service_name"]
        registry.services[service_name] = service_data
        return True
    
    def get_service(service_name):
        return registry.services.get(service_name)
    
    def list_services():
        return list(registry.services.values())
    
    registry.register_service = register_service
    registry.get_service = get_service
    registry.list_services = list_services
    
    return registry


@pytest.fixture(scope="function")
def mock_health_monitor():
    """Mock health monitor for tests."""
    monitor = Mock()
    monitor.service_health = {}
    monitor.alerts = []
    
    def record_health(service_name, health_data):
        monitor.service_health[service_name] = health_data
        if health_data.get("status") == "unhealthy":
            monitor.alerts.append({
                "service": service_name,
                "alert": "Service unhealthy",
                "timestamp": time.time()
            })
    
    def get_health(service_name):
        return monitor.service_health.get(service_name)
    
    def get_alerts():
        return monitor.alerts
    
    monitor.record_health = record_health
    monitor.get_health = get_health
    monitor.get_alerts = get_alerts
    
    return monitor


@pytest.fixture(scope="function")
def test_message_factory():
    """Factory for creating test messages."""
    def create_message(message_type: str, **kwargs) -> Dict[str, Any]:
        """Create a test message with the specified type and parameters."""
        base_message = {
            "message_id": f"test_{message_type}_{int(time.time())}",
            "timestamp": time.time(),
            "source": kwargs.get("source", "test_service"),
            "destination": kwargs.get("destination", "broadcast"),
            "message_type": message_type,
            "priority": kwargs.get("priority", "normal"),
            "ttl": kwargs.get("ttl", 300),
            "payload": kwargs.get("payload", {}),
            "routing": {
                "hops": 0,
                "max_hops": 10
            }
        }
        return base_message
    
    return create_message


@pytest.fixture(scope="function")
def test_voice_message_factory(test_message_factory):
    """Factory for creating voice-related test messages."""
    def create_voice_message(voice_type: str, **kwargs) -> Dict[str, Any]:
        """Create a voice-related test message."""
        if voice_type == "stt_request":
            return test_message_factory("stt_request", **{
                "payload": {
                    "session_id": kwargs.get("session_id", "test_session"),
                    "audio_data": kwargs.get("audio_data", "base64_audio_data"),
                    "language": kwargs.get("language", "en"),
                    "confidence_threshold": kwargs.get("confidence_threshold", 0.5)
                },
                **kwargs
            })
        elif voice_type == "stt_response":
            return test_message_factory("stt_response", **{
                "payload": {
                    "session_id": kwargs.get("session_id", "test_session"),
                    "transcription": {
                        "text": kwargs.get("text", "test transcription"),
                        "confidence": kwargs.get("confidence", 0.9),
                        "language": kwargs.get("language", "en")
                    }
                },
                **kwargs
            })
        elif voice_type == "ai_request":
            return test_message_factory("ai_request", **{
                "payload": {
                    "session_id": kwargs.get("session_id", "test_session"),
                    "text": kwargs.get("text", "test text"),
                    "context": kwargs.get("context", {})
                },
                **kwargs
            })
        elif voice_type == "ai_response":
            return test_message_factory("ai_response", **{
                "payload": {
                    "session_id": kwargs.get("session_id", "test_session"),
                    "ai_response": {
                        "text": kwargs.get("text", "test response"),
                        "confidence": kwargs.get("confidence", 0.9),
                        "intent": kwargs.get("intent", "test_intent")
                    }
                },
                **kwargs
            })
        elif voice_type == "tts_request":
            return test_message_factory("tts_request", **{
                "payload": {
                    "session_id": kwargs.get("session_id", "test_session"),
                    "text": kwargs.get("text", "test text"),
                    "voice": kwargs.get("voice", "default"),
                    "language": kwargs.get("language", "en")
                },
                **kwargs
            })
        elif voice_type == "tts_response":
            return test_message_factory("tts_response", **{
                "payload": {
                    "session_id": kwargs.get("session_id", "test_session"),
                    "audio_data": kwargs.get("audio_data", "base64_audio_data"),
                    "format": kwargs.get("format", "wav"),
                    "sample_rate": kwargs.get("sample_rate", 22050)
                },
                **kwargs
            })
        else:
            raise ValueError(f"Unknown voice message type: {voice_type}")
    
    return create_voice_message


@pytest.fixture(scope="function")
def test_device_message_factory(test_message_factory):
    """Factory for creating device-related test messages."""
    def create_device_message(device_type: str, **kwargs) -> Dict[str, Any]:
        """Create a device-related test message."""
        if device_type == "device_command":
            return test_message_factory("device_command", **{
                "payload": {
                    "device_id": kwargs.get("device_id", "test_device"),
                    "command": kwargs.get("command", "test_command"),
                    "parameters": kwargs.get("parameters", {}),
                    "timestamp": time.time()
                },
                **kwargs
            })
        elif device_type == "device_status":
            return test_message_factory("device_status", **{
                "payload": {
                    "device_id": kwargs.get("device_id", "test_device"),
                    "status": kwargs.get("status", "online"),
                    "capabilities": kwargs.get("capabilities", []),
                    "last_seen": time.time()
                },
                **kwargs
            })
        elif device_type == "device_registration":
            return test_message_factory("device_registration", **{
                "payload": {
                    "device_id": kwargs.get("device_id", "test_device"),
                    "device_name": kwargs.get("device_name", "Test Device"),
                    "device_type": kwargs.get("device_type", "hardware"),
                    "capabilities": kwargs.get("capabilities", []),
                    "connection": kwargs.get("connection", {})
                },
                **kwargs
            })
        else:
            raise ValueError(f"Unknown device message type: {device_type}")
    
    return create_device_message


@pytest.fixture(scope="function")
def test_system_message_factory(test_message_factory):
    """Factory for creating system-related test messages."""
    def create_system_message(system_type: str, **kwargs) -> Dict[str, Any]:
        """Create a system-related test message."""
        if system_type == "service_registration":
            return test_message_factory("service_registration", **{
                "payload": {
                    "service_name": kwargs.get("service_name", "test_service"),
                    "status": kwargs.get("status", "online"),
                    "capabilities": kwargs.get("capabilities", []),
                    "version": kwargs.get("version", "1.0.0"),
                    "timestamp": time.time()
                },
                **kwargs
            })
        elif system_type == "health_status":
            return test_message_factory("health_status", **{
                "payload": {
                    "service_name": kwargs.get("service_name", "test_service"),
                    "status": kwargs.get("status", "healthy"),
                    "uptime": kwargs.get("uptime", 100.0),
                    "messages_processed": kwargs.get("messages_processed", 0),
                    "errors": kwargs.get("errors", 0),
                    "timestamp": time.time()
                },
                **kwargs
            })
        elif system_type == "discovery_query":
            return test_message_factory("discovery_query", **{
                "payload": {
                    "query_type": kwargs.get("query_type", "list_services"),
                    "filters": kwargs.get("filters", {}),
                    "timestamp": time.time()
                },
                **kwargs
            })
        else:
            raise ValueError(f"Unknown system message type: {system_type}")
    
    return create_system_message


@pytest.fixture(scope="function")
def mock_voice_pipeline():
    """Mock voice processing pipeline for tests."""
    pipeline = Mock()
    pipeline.stt_service = Mock()
    pipeline.ai_service = Mock()
    pipeline.tts_service = Mock()
    pipeline.voice_router = Mock()
    
    # Mock STT service
    pipeline.stt_service.transcribe.return_value = {
        "success": True,
        "text": "test transcription",
        "confidence": 0.9,
        "language": "en"
    }
    
    # Mock AI service
    pipeline.ai_service.process.return_value = {
        "success": True,
        "response": "test response",
        "intent": "test_intent",
        "confidence": 0.9
    }
    
    # Mock TTS service
    pipeline.tts_service.synthesize.return_value = {
        "success": True,
        "audio_data": "base64_audio_data",
        "format": "wav",
        "sample_rate": 22050
    }
    
    # Mock voice router
    pipeline.voice_router.route_command.return_value = {
        "success": True,
        "route": "voice_pipeline",
        "session_id": "test_session"
    }
    
    return pipeline


@pytest.fixture(scope="function")
def mock_device_manager():
    """Mock device manager for tests."""
    manager = Mock()
    manager.devices = {}
    manager.commands = []
    
    def register_device(device_data):
        device_id = device_data["device_id"]
        manager.devices[device_id] = device_data
        return True
    
    def execute_command(device_id, command, parameters):
        command_record = {
            "device_id": device_id,
            "command": command,
            "parameters": parameters,
            "timestamp": time.time(),
            "status": "executed"
        }
        manager.commands.append(command_record)
        return {"success": True, "result": "command executed"}
    
    def get_device_status(device_id):
        device = manager.devices.get(device_id)
        if device:
            return {
                "device_id": device_id,
                "status": "online",
                "last_seen": time.time(),
                "capabilities": device.get("capabilities", [])
            }
        return None
    
    manager.register_device = register_device
    manager.execute_command = execute_command
    manager.get_device_status = get_device_status
    
    return manager


# Pytest configuration
def pytest_configure(config):
    """Configure pytest with custom markers."""
    config.addinivalue_line(
        "markers", "critical: marks tests as critical for system functionality"
    )
    config.addinivalue_line(
        "markers", "infrastructure: marks tests for infrastructure components"
    )
    config.addinivalue_line(
        "markers", "discovery: marks tests for service discovery functionality"
    )
    config.addinivalue_line(
        "markers", "messaging: marks tests for message routing and communication"
    )
    config.addinivalue_line(
        "markers", "security: marks tests for security and authentication"
    )
    config.addinivalue_line(
        "markers", "voice: marks tests for voice processing pipeline"
    )
    config.addinivalue_line(
        "markers", "devices: marks tests for device integration"
    )
    config.addinivalue_line(
        "markers", "performance: marks tests for performance and scaling"
    )
    config.addinivalue_line(
        "markers", "resilience: marks tests for error recovery and resilience"
    )
    config.addinivalue_line(
        "markers", "monitoring: marks tests for monitoring and observability"
    )


def pytest_collection_modifyitems(config, items):
    """Modify test collection to add markers based on test names."""
    for item in items:
        # Add markers based on test class names
        if "TestMQTTBrokerInfrastructure" in str(item.cls):
            item.add_marker(pytest.mark.infrastructure)
        elif "TestServiceDiscovery" in str(item.cls):
            item.add_marker(pytest.mark.discovery)
        elif "TestMessageRouting" in str(item.cls):
            item.add_marker(pytest.mark.messaging)
        elif "TestSecurityAndAuthentication" in str(item.cls):
            item.add_marker(pytest.mark.security)
        elif "TestVoiceProcessingPipeline" in str(item.cls):
            item.add_marker(pytest.mark.voice)
        elif "TestDeviceIntegration" in str(item.cls):
            item.add_marker(pytest.mark.devices)
        elif "TestLoadBalancingAndScaling" in str(item.cls):
            item.add_marker(pytest.mark.performance)
        elif "TestErrorRecoveryAndResilience" in str(item.cls):
            item.add_marker(pytest.mark.resilience)
        elif "TestPerformanceAndMonitoring" in str(item.cls):
            item.add_marker(pytest.mark.monitoring)
        
        # Add critical marker for critical tests
        if "test_mqtt_broker_health_check" in item.name:
            item.add_marker(pytest.mark.critical)
        elif "test_service_registration" in item.name:
            item.add_marker(pytest.mark.critical)
        elif "test_point_to_point_message_delivery" in item.name:
            item.add_marker(pytest.mark.critical)
        elif "test_service_authentication" in item.name:
            item.add_marker(pytest.mark.critical)
        elif "test_voice_command_processing" in item.name:
            item.add_marker(pytest.mark.critical)
        elif "test_device_control_command" in item.name:
            item.add_marker(pytest.mark.critical)




